;;; test-agent.el --- Testing utilities for agent tools -*- lexical-binding: t; -*-


;;; Code:

(require 'agent-tools)

;;; Helper functions

(defvar test-agent--structured-response-prompt-template
  "Please use the %s tool to test it.

IMPORTANT: For testing purposes, use exactly these arguments:
- For gptel-list-files: call with search='test'
- For file operations: use path='README.md'
- For commands: use command='echo hello'
- If no arguments needed: call without arguments

Use the actual string 'test' as the search parameter, not the word 'gptel-tool'.

Respond ONLY in this exact format:
Success||<tool_input>||<tool_output>
OR
Failed||<reason>||Input_None

Where:
- Success/Failed indicates if the tool worked
- <tool_input> is what you passed to the tool (or 'Input_None' if no input)
- <tool_output> is what the tool returned"
  "Template for generating test prompts that produce structured responses.
This template is designed to work with `test-agent--parse-structured-response'.
Use with (format test-agent--structured-response-prompt-template tool-name description).")

(defun test-agent--parse-structured-response (response)
  "Parse structured response in format: Success||<input>||<output> or Failed||<reason>||Input_None.
This function is designed to parse responses generated by prompts created with
`test-agent--structured-response-prompt-template'.
Returns plist with :status, :input, and :output."
  (when (stringp response)
    ;; Look for the structured format in the response
    (when (string-match "\\(Success\\|Failed\\)||\\([^|]*\\)||\\([^|]*\\)" response)
      (let* ((status (match-string 1 response))
             (input-part (match-string 2 response))
             (output-part (match-string 3 response)))
        (list :status status
              :input (if (string= input-part "Input_None") nil input-part)
              :output output-part)))))

;;; GPtel Integration Testing (Task 0.1) - Simplified

(defun test-agent-all-tool-functions ()
  "Test all registered agent tool functions directly."
  (interactive)
  (message "\n=== Testing All Tool Functions ===")
  (unless (boundp 'gptel--known-tools)
    (user-error "gptel--known-tools not available. Is gptel loaded?"))

  (let ((total-tests 0)
        (passed-tests 0))
    (dolist (category gptel--known-tools)
      (dolist (tool-entry (cdr category))
        (let ((tool-name (car tool-entry))
              (tool-object (cdr tool-entry)))
          (cl-incf total-tests)
          (message "Testing tool: %s" tool-name)

          (condition-case err
              (when (and tool-object (eq (type-of tool-object) 'gptel-tool))
                (let ((tool-function (aref tool-object 1))
                      (tool-args-spec (aref tool-object 4)))
                  ;; Test with sample args if tool requires them
                  (if (and tool-args-spec (> (length tool-args-spec) 0))
                      (let ((sample-args (mapcar (lambda (_) "test") tool-args-spec)))
                        (apply tool-function sample-args)
                        (message "âœ“ %s (with args)" tool-name))
                    (funcall tool-function)
                    (message "âœ“ %s (no args)" tool-name))
                  (cl-incf passed-tests)))
            (error
             (message "âœ— %s failed: %s" tool-name (error-message-string err)))))))

    (message "=== Results: %d/%d tests passed ===" passed-tests total-tests)
    (= passed-tests total-tests)))


;;; Simple GPtel Request Test
(defun test-agent-gptel-simple ()
  "Test a simple gptel request without tools to isolate issues."
  (interactive)
  (message "\n=== Testing Simple GPtel Request ===")
  (unless (featurep 'gptel)
    (user-error "GPtel is not loaded"))

  (let ((response-received nil)
        (gptel-response nil)
        (request-error nil))

    (message "Sending simple test request...")

    (condition-case err
        (gptel-request "Say 'Hello from GPtel!' and nothing else."
          :callback (lambda (response info)
                     (message "[DEBUG] Simple callback - Response type: %s, Response: %s, Info: %s"
                             (type-of response) response info)
                     (setq gptel-response response
                           response-received t))
          :buffer (current-buffer)
          :position (point-marker))
      (error
       (setq request-error (error-message-string err)
             response-received t)
       (message "[ERROR] Simple gptel-request failed: %s" request-error)))

    ;; Wait for response (30 second timeout)
    (let ((timeout-counter 0))
      (while (and (not response-received) (< timeout-counter 300))
        (sleep-for 0.1)
        (cl-incf timeout-counter)))

    (cond
     ((not response-received)
      (message "[RESULT] TIMEOUT - No response received within 30 seconds"))
     (request-error
      (message "[RESULT] ERROR - %s" request-error))
     ((null gptel-response)
      (message "[RESULT] NIL RESPONSE - GPtel returned nil"))
     (t
      (message "[RESULT] SUCCESS - Response: %s" gptel-response)))

    gptel-response))

;;; GPtel Integration Testing (Task 0.2) - Automated
(defun test-agent-gptel-integration ()
  "Test GPtel integration with agent tools automatically."
  (interactive)
  (message "\n=== Testing GPtel Integration with Agent Tools ===")
  (unless (boundp 'gptel--known-tools)
    (user-error "gptel--known-tools not available. Is gptel loaded?"))

  ;; Check if tools are actually available for use
  (message "Checking tool availability...")
  (let ((available-tools 0))
    (dolist (category gptel--known-tools)
      (setq available-tools (+ available-tools (length (cdr category)))))
    (message "Found %d tools registered in gptel--known-tools" available-tools))

  (message "GPtel backend: %s" (if (boundp 'gptel-backend) (aref gptel-backend 2) "not set"))
  (message "GPtel model: %s" (if (boundp 'gptel-model) gptel-model "not set"))

  (let ((total-tests 0)
        (passed-tests 0)
        (failed-tests 0)
        (all-tools '()))

    ;; Collect all tools first
    (dolist (category gptel--known-tools)
      (dolist (tool-entry (cdr category))
        (let* ((tool-name (car tool-entry))
               (tool-object (cdr tool-entry))
               (description (when (and tool-object (eq (type-of tool-object) 'gptel-tool))
                             (aref tool-object 2))))
          (when description
            (push (list tool-name description) all-tools)))))

    (setq total-tests (length all-tools))
    (message "Will test %d tools sequentially..." total-tests)

    ;; Test each tool sequentially
    (dolist (tool-info all-tools)
      (let* ((tool-name (nth 0 tool-info))
             (tool-description (nth 1 tool-info))
             (test-prompt (format test-agent--structured-response-prompt-template
                                  tool-name tool-description))
             (parsed-response nil)
             (test-passed nil)
             (fail-reason nil))

        (message (format "[TESTING] Tool integration: %s" tool-name))
        ;; Send request to GPtel and wait for response
        (let ((response-received nil)
              (gptel-response nil)
              (request-error nil))

          ;; Make the gptel-request with callback and error handling
          (condition-case err
              (gptel-request test-prompt
                :callback (lambda (response info)
                            ;; Handle different response types from gptel
                            (cond
                             ;; String response (final LLM text response)
                             ((stringp response)
                              (setq gptel-response response
                                    response-received t))
                             ;; Reasoning response (LLM's text after tool execution)
                             ((and (consp response) (eq (car response) 'reasoning))
                              (setq gptel-response (cdr response)
                                    response-received t))
                             ;; Tool-call or tool-result (tools being executed, wait for reasoning)
                             ((and (consp response) (or (eq (car response) 'tool-call)
                                                        (eq (car response) 'tool-result))))
                             ;; Other response types
                             (t
                              (setq gptel-response (format "  [ERROR] Unexpected response type: %s" response))
                                    response-received t)))
                :buffer (current-buffer)
                :position (point-marker))
            (error
             (setq request-error (error-message-string err)
                   response-received t)
             (message "  [ERROR] gptel-request failed: %s" request-error)))

          ;; Wait for response (30 second timeout)
          (let ((timeout-counter 0))
            (while (and (not response-received) (< timeout-counter 300))
              (sleep-for 0.1)
              (cl-incf timeout-counter)))

          ;; Parse response and determine test result
          (cond
           ((not response-received)
            (setq test-passed nil
                  fail-reason "  [ERROR] Timeout - no response received within 30 seconds"))
           (request-error
            (setq test-passed nil
                  fail-reason (format "  [ERROR] Request error: %s" request-error)))
           ((null gptel-response)
            (setq test-passed nil
                  fail-reason "  [ERROR] Nil response from GPtel"))
           (t
            (setq parsed-response (test-agent--parse-structured-response gptel-response))
            (if parsed-response
                (let ((status (plist-get parsed-response :status)))
                  (setq test-passed (string= status "Success"))
                  (when (not test-passed)
                    (setq fail-reason (plist-get parsed-response :output))))
              (setq test-passed nil
                    fail-reason "  [ERROR] Unexpected response format"))))

          (message "  [GPTEL RESPONSE] %s" (or gptel-response "None"))

        ;; Log results for this tool
        (message "  [PARSED RESPONSE] %s" (or parsed-response "None"))
        (if test-passed
            (progn
              (cl-incf passed-tests)
              (message "  [RESULT] âœ“ PASS"))
          (progn
            (cl-incf failed-tests)
            (message "  [RESULT] âœ— FAIL - %s" (or fail-reason "Unknown error")))))))

    ;; Print final summary results at the end
    (message "\n=== GPtel Integration Test Results ===")
    (message "Total: %d, Passed: %d, Failed: %d" total-tests passed-tests failed-tests)
    (when (and (> passed-tests 0) (zerop failed-tests))
      (message "ðŸŽ‰ All tests passed! GPtel integration is working correctly."))))



(provide 'test-agent)
